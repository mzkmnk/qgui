# フェーズ 5: パフォーマンス最適化 - 機能単位 TDD 実装

## 概要

YAGNI原則に従い、実際にパフォーマンス問題が発生した場合のみ最適化を実施する。
過早な最適化は避け、必要最小限の改善のみ行う。

## 重要な前提

**現時点でパフォーマンス問題が発生していない場合、このフェーズはスキップする。**

## パフォーマンス問題が発生した場合の対応

### 1. 問題の特定と測定（必要時のみ）

#### 1.1 簡易パフォーマンス測定

- [ ] **問題確認**: ユーザーが体感できる遅延があるか確認
- [ ] **簡易測定**: ブラウザの開発者ツールで確認
  ```typescript
  // 必要最小限の測定
  console.time('operation');
  // 処理
  console.timeEnd('operation');
  ```
- [ ] **ボトルネック特定**: 最も時間がかかる処理を特定

### 2. 最小限の最適化（問題がある場合のみ）

#### 2.1 明らかに非効率な実装の修正

- [ ] **条件**: 1000件以上のデータで画面がフリーズする場合
  - [ ] **Red**: パフォーマンステスト作成
  - [ ] **Green**: trackByの追加など最小限の修正
  ```typescript
  // 最小限の修正例
  trackByFn(index: number, item: any): any {
    return item.id || index;
  }
  ```

#### 2.2 不要な処理の削除

- [ ] **条件**: 同じ処理が何度も実行されている場合
  - [ ] **Red**: 重複処理の検出テスト
  - [ ] **Green**: 重複処理の削除

### 3. バンドルサイズ問題（1MB超えた場合のみ）

#### 3.1 大きすぎるライブラリの確認

- [ ] **条件**: 初期ロードが5秒以上かかる場合
  - [ ] **測定**: `npm run build` でサイズ確認
  - [ ] **対応**: 使用していないライブラリの削除のみ

## 削除した項目（YAGNI原則）

以下の項目は実際に必要になるまで実装しない：

**フロントエンド最適化**
- Core Web Vitalsの詳細な測定と最適化
- ChangeDetection戦略の複雑な最適化
- 仮想スクロール（数千件表示が必要になるまで）
- Service Worker（オフライン対応が必要になるまで）
- 遅延読み込み（初期ロードが問題になるまで）
- Tree Shaking（バンドルサイズが問題になるまで）
- メモリリーク対策（実際にリークが発生するまで）

**バックエンド最適化**
- Redis統合（メモリキャッシュで十分）
- データベースインデックス最適化（クエリが遅くなるまで）
- 接続プール（同時接続が問題になるまで）
- 圧縮（通信量が問題になるまで）

**WebSocket/PTY最適化**
- メッセージバッファリング（遅延が問題になるまで）
- バックプレッシャー制御（過負荷が発生するまで）
- プロセスプール（起動時間が問題になるまで）

**監視・分析**
- パフォーマンス監視ダッシュボード
- 継続的なメトリクス収集
- 負荷テスト・ストレステスト
- ベンチマークテスト

## 対応方針

### パフォーマンス問題が発生した場合

1. **具体的な問題を特定する**
   - どの操作が遅いか
   - どのくらい遅いか
   - いつから遅くなったか

2. **最小限の修正で解決を試みる**
   - 明らかなバグの修正
   - 不要な処理の削除
   - 簡単な最適化（trackBy追加など）

3. **それでも解決しない場合のみ、より高度な最適化を検討**

## 各PRの完了条件（問題発生時のみ）

- [ ] 具体的なパフォーマンス問題が測定されている
- [ ] 最小限の修正で問題が解決している
- [ ] 新たな問題を引き起こしていない
- [ ] テストが全てGreen

## 重要な注意事項

- **推測で最適化しない** - 実際の問題のみ対処
- **測定してから最適化** - 問題を数値で確認
- **最小限の変更** - 大規模な書き換えは避ける
- **ユーザー体験優先** - 技術的な完璧さより使いやすさ